---
title: "Prática Ciência de Dados no R"
output:
  html_document:
    df_print: paged
  pdf_document: default
---

Prática de ciência de dados no R em que serão respondidas 12 perguntas a respeito dos dados de vendas de eletrônicos ao longo de 12 meses. O arquivo se chama all_data.

Cada linha do data frame representa o item de uma compra que pode ou não conter mais itens; temos também a data e hora da compra, o valor do item e a quantidade comprada, além do endereço completo. Isso significa que linhas diferentes com o mesmo ID representam diferentes produtos que foram comprados simultâneamente, com entrega para um único endereço. Além disso, não deve haver linhas idênticas.

### Limpeza e organização

Vamos inicialmente ler e analisar o data frame e o conteúdo de suas colunas

```{r message=FALSE, warning=FALSE}
library(dplyr)
library(ggplot2)
library(dygraphs)
library(tidyverse)
library(hrbrthemes)
library(forcats)
library(viridis)

all_data <- read.csv("C:/Users/Gisele/Desktop/Pandas-Data-Science-Tasks-master/all_data.csv", stringsAsFactors=T)
```

```{r}
head(all_data,n=30)

summary(all_data)

```

A função *summary* nos mostra alguns problemas: todas as variáveis foram interpretadas como fatores, há linhas completamente vazias e outras preenchidas com o nome da respectiva variável.

Vamos primeiro remover as linhas vazias, em seguida as linhas preenchidas com o nome da coluna.

```{r}
#remove linhas vazias
dados = all_data[!apply(all_data == "", 1, all), ]

#remove linhas cujo valor da coluna Order.ID seja 'Order ID' 
dados = subset(dados, Order.ID != 'Order ID')

```

A partir de agora, trabalharemos apenas com o data frame 'dados'

As variáveis 'Quantity.Ordered' e 'Price Each' foram interpretados como fatores. Vamos converter para o formato numérico, mas antes, precisamos converter para o formato 'character' do R

```{r}
dados$Quantity.Ordered = as.numeric(as.character(dados$Quantity.Ordered))
dados$Price.Each = as.numeric(as.character(dados$Price.Each))

```

Agora que os dados estão prontos para o uso, vamos chamar novamente a função *summary*

```{r}

summary(dados)

summary(as.factor(dados$Product))
head(summary(as.factor(dados$Purchase.Address)))

paste('Número total de produtos vendidos:',sum(dados$Quantity.Ordered))

```

Alguns resultados interessantes:

O produto mais vendido foi 'USB-C Charging Cable', com 21903 unidades vendidas

O item mais barato custou 2.99, e o mais caro, 1700 dólares.

------------------------------------------------------------------------

Podemos ver a quantidade de endereços diferentes registrada

```{r}

paste('Número de endereços:', nlevels(as.factor(dados$Purchase.Address)))
```

E a distribuição do número de unidade por produto.

```{r}
value=as.factor(dados$Quantity.Ordered)
value =summary(value)
value

```

A maioria absoluta dos produtos foi comprada como item único (168552), enquanto dois itens iguais foram pedidos em apenas 13324 vezes, caindo ainda mais para 2920 para 3 itens iguais na mesma compra.

### Qual foi o melhor mês de vendas

Começaremos obtendo uma coluna com o valor total de cada linha

```{r}
dados$Value = dados$Quantity.Ordered * dados$Price.Each


```

Precisamos extrair o mês de cada venda e associar à uma nova coluna

Como o mês é indicado pelos primeiros dois caracteres da data de compra, extraímos esses caracteres com a função *substr(x,start,stop)*

```{r}

dados$month = substr(as.character(dados$Order.Date), start=1,stop=2)

head(dados)
```

Agora, podemos obter o valor total vendido em cada mês e salvar num novo date frame. É importante lembrar que as vendas do primeiro dia de 2020 também foram registradas e serão contabilizadas juntamente com as vendas de janeiro de 2019.

```{r}

venda.mes=aggregate(Value ~month,
                    data=dados,FUN=sum)


venda.mes
```

```{r}
venda.mes$month=month.abb

library(forcats)

#reordena em ordem decrescente com o pacote forcats. A função mutate é do pacote dplyr
venda.mes %>%
   mutate(month = fct_reorder(month, Value)) %>%
  
 ggplot( aes(x=month, y=Value)) +
    geom_bar(stat="identity", fill="#f68060", alpha=.75, width=.4) +
    coord_flip() +
    ylab("Valor vendido no mês em dólares") +
    xlab("")+
    theme_ipsum(base_family = "Calibri")

```

### Em que horas do dia foram registradas mais vendas?

Vamos extrair o horário da venda de maneira similar a como fizemos com a data. Para isso, basta notar que a hora da compra são os caracteres 10 e 11 das célula de Order.Date

```{r}

dados$Hour = substr(as.character(dados$Order.Date), start=10,stop=11)


```

E então podemos verificar a relação entre o valor das vendas e a hora ou a quantidade de itens vendidos e a hora.

```{r}
#Valor total vendido para cada hora do dia
venda.hora=aggregate(Value ~Hour,
                    data=dados,FUN=sum)


venda.hora


```

```{r results='hide'}


a=venda.hora %>%

 ggplot( aes(x=Hour, y=Value, group=1)) +
   geom_line( color="grey") +
   geom_point(shape=21, color="yellow", fill="#69b3a2", size=3) +
   theme_ipsum(base_family = "Calibri") +
    labs(
    x = "Hora do dia", 
    y = "Valor Vendido em dólares", 
    title = " Evolução do Valor das Vendas"

  )
   

a


```

Também podemos observar a evolução das vendas de cada produto ao longo do dia:

```{r fig.height=12, fig.width=15}

dados3 =dados %>%
   
   filter(Product %in% c("AAA Batteries (4-pack)","iPhone","Apple Airpods Headphones" ,"Lightning Charging Cable","Wired Headphones" ,"Bose SoundSport Headphones","AA Batteries (4-pack)","USB-C Charging Cable","27in FHD Monitor"))


          
dados3 %>%          
ggplot( aes(x=Hour, y=Quantity.Ordered, color=Product  )) + 
  geom_area() +  
  facet_wrap(~Product , dir="v")  +
  theme(legend.position="none",axis.text.x = element_blank())


```

**Conclusão**

Compras no site foram realizadas com mais frequência entre 10h e 21h, atingindo picos as 12 e também as 19h. Os produtos não apresentam divergência quanto à isso: todos apresentaram o mesmo formato de distribuição, variando apenas na quantidade, que manteve a proporção ao longo de todo o dia.

### Quais dias do mês venderam mais?

Vamos agora utilizar o pacote lubridate que funciona da seguinte forma:

time = c("2019-04-17", "2019-01-23") - **isto está no formato character**

ymd(time) - **isto está em formato de data**

A vantagem do formato de data do R, é que o ggplot o reconhece automaticamente. Vamos então extrair a data das compras.

```{r message=FALSE, warning=FALSE}
library(lubridate)

#usa a função mdy do pacote lubridate para converter a data da compra que é representda pelos characteres de 1 a 8 de Order.Date
dados$Date = mdy(substr(as.character(dados$Order.Date), start=1,stop=8))

str(dados)
```

Note que a nova variável 'Date' é do tipo Date, e não factor ou character.

Usando a função *xts* do pacote xts, criamos um novo data frame que é indexado pelas datas. Em segida, usamos *apply.daily* do mesmo pacote para obter a soma das vendas de cada dia.

```{r message=FALSE, warning=FALSE}
library(xts)

venda.data = xts(dados[, "Value"], order.by = dados$Date)

venda.data = apply.daily(venda.data, sum)
```

**Observação:** podemos obter o valor de venda de cada mês de uma forma mais precisa agora que temos o pacote xts

```{r}
apply.monthly(venda.data,sum)

library(dygraphs)
dygraph(apply.monthly(venda.data,sum), main = 'Evolução das vendas por mês')

```

Podemos também fazer um gráfico interativo da distribuição da evolução das vendas por dia.

```{r echo=FALSE}

dygraph(venda.data, main = 'Evolução das vendas por dia') %>%
  dyRangeSelector()

```

### Qual cidade vendeu mais?

Precisamos extrair a cidade e o estado pois há duas cidade com o mesmo nome em estados diferentes. Depois, basta aplicar a função *aggregate* novamente.

Agora, não é possível saber exatamente quais serão os índices a serem selecionados, pois os endereços não tem um formato padrão como hora e data. Então, vamos separar a string do endereço primeiro, utilizando a vírgula como separador para então selecionarmos a cidade e o estado.

```{r}

#strsplit retorna uma lista
city=  strsplit(as.character(dados$Purchase.Address), split = ','); city[1]; city[2]

#convertendo para o formato vetor e selecionando apenas a cidade e o estado (a cidade é o segundo elemento e o estado são os caracteres 2 e 3 do terceiro elemento de cada objeto da lista)
city = unlist(lapply(city, function(x)  paste(x[2],substr(x[3],start=2,stop=3))))

paste("Cada elemento do vetor city contem a cidade e o estado de cada compra:")
paste("City[1]:",city[1])


dados$City = city


```

Agora que temos a coluna com cidade e estado, usamos a função *aggregate* novamente

```{r}

venda.cidade = aggregate(Value ~ City, dados,  sum)

venda.cidade
  
```

```{r}
venda.cidade %>%
   mutate(City = fct_reorder(City, Value)) %>%

ggplot( aes(x=City, y=Value)) +
    geom_bar(stat="identity", fill="#F10C55", alpha=.75, width=.4) +
    coord_flip() +
    ylab("Valor vendido em dólares") +
    xlab("")+
    theme_ipsum(base_family = "Calibri")



```

```{r fig.height=10, fig.width=15}

venda.cidade.mes = aggregate(Value ~(City+month),dados,sum)

venda.cidade.mes$month = as.numeric(venda.cidade.mes$month)

tmp <- venda.cidade.mes %>%
  mutate(City2=City)

tmp %>%
  ggplot( aes(x=month, y=Value)) +
    geom_line( data=tmp %>% dplyr::select(-City), aes(group=City2), color="grey", size=0.8, alpha=0.5) +
    geom_line( aes(color=City), color="#69b3a2", size=1.8 )+
    scale_color_viridis(discrete = TRUE) +
    theme_ipsum(base_family= "Calibri",grid = FALSE) +
    theme(
      legend.position="none",
      plot.title = element_text(size=18),
      axis.title.x = element_blank(),
      axis.text.x = element_blank(),
      axis.text.y = element_blank()
      ) +
    ggtitle("Vendas por cidade ao longo do ano") +
    facet_wrap(~City)

```

Podemos observar o mesmo comportamento em todas as cidades: as vendas sobem de janeiro a abril e depois caem até o fim de setembro, antes de voltarem a subir rapidamente.

### Quais produtos são mais frequentemente vendidos juntos?

Primeiro precisamos reunir as vendas por ID e acrescentar os produtos. Mas antes, vamos verificar se existem linhas iguais:

```{r}
dados[duplicated(dados) | duplicated(dados, fromLast=TRUE),]

```

```{r}
#remove linhas cujos IDs e Produtos sejam iguais e associa a um novo datta frame

venda.id <-
  dados %>%
  distinct(Order.ID,Product, .keep_all=FALSE) 
  

```

Agora, vamos usar a função *count* do pacote dplyr para criar um novo data frame com a frequência dos níveis.

```{r}
library(dplyr)

id = count(venda.id, Order.ID)
head(id)

#seleciona apenas os ID's cuja frequência é maior que um, como queríamos
id= id %>%
  filter(n>1)

head(id)
```

E então podemos usar o objeto id para atualizar o data frame venda.id

```{r}

venda.id = venda.id %>%
   
   filter(Order.ID %in% id$Order.ID  )

head(venda.id,20)
```

Note que agora todos os ID's aparecem no mínimo duas vezes.

Para fazer a contagem dos pares mais frequentes utilizamos o código abaixo: *combn(unique(x), 2, paste, collapse="-")* encontra as combinações únicas dos produtos e os mostra juntos, *tapply* agrupa por ID e retorna uma lista, *unlist* transforma num vetor e *table* calcula as frequências de cada combinação. Essas frequências são sorteadas em ordem decrescente e *tail* seleciona as 5 maiores.

**Obs:** O código resulta em erro se a variável produto for do tipo factor

```{r }

teste=venda.id

results = tail(sort(table(unlist(tapply(as.character(teste$Product), teste$Order.ID, FUN=function(x) combn(unique(x), 2, paste, collapse=" and "))))),
           5)


(results)
```
Podemos ver na tabela acima a contagem dos pares de produtos mais vendidos. 



